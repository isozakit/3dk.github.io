<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GLB Viewer — Collection 切替スイッチ</title>
  <style>
    :root{
      --sidebar-width: 300px;
      --controls-height-vh: 35vh; /* portrait の時の下部コントロール高さ（30-40%の間で調整） */
    }
    html,body{height:100%;margin:0;font-family:system-ui, -apple-system, 'Segoe UI', Roboto, 'Hiragino Kaku Gothic ProN', 'Noto Sans JP';}
    /* Default: landscape/desktop layout (left sidebar) */
    #app{display:grid;grid-template-columns:var(--sidebar-width) 1fr;height:100vh;grid-template-rows:1fr}
    #sidebar{padding:12px;border-right:1px solid #ddd;overflow:auto;background:#fff}
    #viewer{background:#111;min-height:0} /* min-height for flex/grid shrinking */
    .collection-item{display:flex;align-items:center;margin:6px 0}
    label{margin-left:8px}
    header{font-weight:700;margin-bottom:8px;position:relative}
    .hint{font-size:13px;color:#666;margin-top:10px}
    button{margin-top:8px;padding:6px 10px;border-radius:6px;border:1px solid #ccc;background:#fff}

    /* Portrait: viewer 上 / controls 下 */
    @media (orientation: portrait) and (max-width: 1200px) {
      #app {
        display:flex;
        flex-direction: column;
        height:100vh;
      }

      #viewer {
        flex: 1 1 auto;        /* ← 高さを自動で埋める */
        background:#111;
      }

      #sidebar {
        flex: 0 0 var(--controls-height-vh); /* ← 下部に固定配置（30～40%） */
        border-top: 1px solid #ddd;
        overflow:auto;
        padding:10px;
        background:#fff;
      }
    }

    /* Fallback small screens: also treat narrow as portrait-like */
    @media (max-width: 600px) and (orientation: landscape) {
      /* keep default left sidebar but reduce width a bit */
      #app { grid-template-columns: 25% 75%; }
    }
#copyright-watermark {
  position: fixed;
  right: 10px;
  bottom: 10px;
  padding: 4px 10px;
  font-size: 12px;
  color: rgba(255,255,255,0.75);
  background: rgba(0,0,0,0.35);
  border-radius: 6px;
  backdrop-filter: blur(3px);
  pointer-events: none; /* ←クリック操作を邪魔しない */
  z-index: 9999;
}
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
        "OrbitControls": "https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js",
        "GLTFLoader": "https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js"
      }
    }
  </script>
</head>
<body>
  <div id="app">
    <aside id="sidebar">
      <header>Collection Visibility</header>
      <div id="controls">Loading…</div>
      <div class="hint">Toggle groups to show or hide parts of the model. Use your mouse to rotate and zoom.</div>
    </aside>
    <main id="viewer"></main>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'OrbitControls';
    import { GLTFLoader } from 'GLTFLoader';

    const GLB_PATH = 'mouthmove-demo2-18.glb';
    const mapping = {
      '1.a-あ': ['line-ja','line-ja-moji-a','line-ja-moji-a002','moji_ea'],
      '2.i-い': ['line-ji','line-ji-moji-i','line-ji-moji-i001','mojii_ei'],
      '3.u-う': ['line-ju','line-ju-moji-u','moji_eu'],
      '4.e-え': ['line-je','line-je-moji-e','line-je-moji-e001','moji_ee'],
      '5.o-お': ['line-jo','line-jo-moji-o','line-jo-moji-o001','moji_eo'],
      '6.k1-으': ['line-keo','line-keo-moji-keo'],
      '7.k2-우': ['line-ku','line-ku-moji-ku'],
      '8.k3-어': ['line-kwu','line-kwu-moji-kwu']
    };

    /* DOM refs */
    const container = document.getElementById('viewer');
    const controlsPane = document.getElementById('controls');

    /* three setup */
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
    camera.position.set(0, 1.6, 3);

    /**************************************************************************
     * Renderer: optimized defaults
     **************************************************************************/
    const MAX_DPR = 1.0; // set to 0.75 or 1.0 based on desired perf/quality
    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, MAX_DPR));
    renderer.shadowMap.enabled = false;
    container.appendChild(renderer.domElement);
    renderer.domElement.style.width = '100%';
    renderer.domElement.style.height = '100%';
    renderer.domElement.style.display = 'block';

    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.target.set(0, 1, 0);
    orbit.update();

    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    hemi.position.set(0, 20, 0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(3, 10, 10);
    scene.add(dir);

    /* loader */
    let modelRoot = null;
    const loader = new GLTFLoader();
    controlsPane.innerText = 'Loading…';

    /**************************************************************************
     * Render control state (must be declared before any requestRender calls)
     **************************************************************************/
    let needsRender = false;      // if true, next tick will render
    let isInteracting = false;    // true while OrbitControls is being used
    let animationLoopRunning = false;
    let lastRenderTime = 0;
    const TARGET_FPS = 30; // when interacting, cap FPS to limit CPU

    // requestRender as function declaration (safe)
    function requestRender() {
      needsRender = true;
      if (!animationLoopRunning) startAnimationLoop();
    }

    function startAnimationLoop() {
      if (animationLoopRunning) return;
      animationLoopRunning = true;
      lastRenderTime = performance.now();
      requestAnimationFrame(tick);
    }

    function stopAnimationLoop() {
      animationLoopRunning = false;
    }

    function tick(now) {
      if (!animationLoopRunning) return;
      const dt = now - lastRenderTime;

      if (isInteracting) {
        // during interaction, render at up to TARGET_FPS
        if (dt >= (1000 / TARGET_FPS)) {
          renderer.render(scene, camera);
          lastRenderTime = now;
          needsRender = false;
        }
      } else {
        // not interacting: render only when needed (on-demand)
        if (needsRender) {
          renderer.render(scene, camera);
          needsRender = false;
          lastRenderTime = now;
        } else {
          // nothing to render, stop the loop to save CPU
          animationLoopRunning = false;
          return;
        }
      }
      requestAnimationFrame(tick);
    }

    // OrbitControls events to switch interaction mode and request renders
    orbit.addEventListener('start', () => {
      isInteracting = true;
      requestRender();
    });
    orbit.addEventListener('change', () => {
      requestRender();
    });
    orbit.addEventListener('end', () => {
      isInteracting = false;
      requestRender();
    });

    // visibility: pause rendering when tab is hidden
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        stopAnimationLoop();
      } else {
        requestRender();
      }
    });

    /**************************************************************************
     * GLTF load + rest of UI
     **************************************************************************/
    loader.load(GLB_PATH, (gltf) => {
      const model = gltf.scene || (gltf.scenes && gltf.scenes[0]);
      if (!model) {
        controlsPane.innerText = 'Model empty (gltf.scene is null). Check console.';
        console.error('gltf.scene is null', gltf);
        return;
      }

      window.modelRoot = model;
      window.appScene = scene;

      modelRoot = model;
      scene.add(model);

      // fit camera
      const bbox = new THREE.Box3().setFromObject(model);
      const size = bbox.getSize(new THREE.Vector3()).length();
      const center = bbox.getCenter(new THREE.Vector3());
      orbit.target.copy(center);
      orbit.update();
      camera.position.copy(center).add(new THREE.Vector3(0, size * 0.5, size * 1.5));
      camera.updateProjectionMatrix();

      buildSimpleGroupUI(modelRoot, mapping);

      // ensure initial sizing after model added
      updateRendererSize();
      requestRender(); // render first view
    }, (xhr) => {
      try {
        if (xhr && xhr.lengthComputable) {
          controlsPane.innerText = `Loading… ${(xhr.loaded / xhr.total * 100).toFixed(0)}%`;
        } else {
          controlsPane.innerText = 'Loading…';
        }
      } catch (e) {
        controlsPane.innerText = 'Loading…';
      }
    }, (err) => {
      controlsPane.innerText = 'Failed to load model. Check console.';
      console.error('GLB load error:', err);
    });

    /* helpers (same as before) */
    function normalizeNameForMatch(name) {
      if (!name) return '';
      return name.toString().replace(/^[\s\>\<＞｜\|\u2502vV]+/, '').trim();
    }
    function resolveNodeByNameFlexible(root, targetName) {
      if (!root || !targetName) return null;
      let found = null;
      root.traverse(n => { if (found) return; if (n.name === targetName) found = n; });
      if (found) return found;
      const normTarget = normalizeNameForMatch(targetName);
      root.traverse(n => { if (found) return; if (normalizeNameForMatch(n.name) === normTarget) found = n; });
      if (found) return found;
      root.traverse(n => { if (found) return; const nm = n.name || ''; if (nm && nm.includes(targetName)) found = n; });
      if (found) return found;
      root.traverse(n => { if (found) return; const nm = normalizeNameForMatch(n.name); if (nm && nm.includes(normTarget)) found = n; });
      return found;
    }
    function setVisibilityRecursive(node, visible) {
      if (!node) return;
      try { node.visible = visible; } catch (e) { console.warn('cannot set visible', node, e); }
      if (node.children && node.children.length) node.children.forEach(c => setVisibilityRecursive(c, visible));
    }

    function buildSimpleGroupUI(root, mappingObj) {
      controlsPane.innerHTML = '';
      const nameToNode = {};
      root.traverse(n => { if (n.name) nameToNode[n.name] = n; });
      const fragment = document.createDocumentFragment();
      const labels = Object.keys(mappingObj);
      const groupMap = {};
      labels.forEach((label, idx) => {
        const wantedNames = mappingObj[label] || [];
        const resolved = [];
        const unresolved = [];
        wantedNames.forEach(nm => {
          const node = nameToNode[nm] || resolveNodeByNameFlexible(root, nm);
          if (node) resolved.push(node);
          else unresolved.push(nm);
        });
        groupMap[label] = resolved;
        const row = document.createElement('div');
        row.className = 'collection-item';
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.margin = '6px 0';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `grp_${idx}`;
        checkbox.style.marginRight = '8px';
        if (resolved.length) {
          checkbox.checked = resolved[0].visible !== undefined ? resolved[0].visible : true;
        } else {
          checkbox.checked = true;
          checkbox.disabled = true;
          row.style.opacity = '0.6';
        }
        const labelEl = document.createElement('label');
        labelEl.htmlFor = checkbox.id;
        labelEl.textContent = label;
        labelEl.style.userSelect = 'none';
        labelEl.style.cursor = resolved.length ? 'pointer' : 'default';
        row.appendChild(checkbox);
        row.appendChild(labelEl);
        fragment.appendChild(row);
        if (unresolved.length) console.warn(`Group "${label}" unresolved items:`, unresolved);
        checkbox.addEventListener('change', () => {
          const v = checkbox.checked;
          resolved.forEach(n => setVisibilityRecursive(n, v));
          requestRender();
        });
        labelEl.addEventListener('click', () => {
          if (checkbox.disabled) return;
          checkbox.checked = !checkbox.checked;
          checkbox.dispatchEvent(new Event('change'));
        });
      });
      // Display All button (optional)
      const displayAllRow = document.createElement('div');
      displayAllRow.style.marginTop = '10px';
      displayAllRow.style.display = 'flex';
      displayAllRow.style.gap = '8px';
      displayAllRow.style.alignItems = 'center';
      const displayAllBtn = document.createElement('button');
      displayAllBtn.textContent = 'Display All';
      displayAllBtn.style.padding = '6px 10px';
      displayAllBtn.style.borderRadius = '6px';
      displayAllBtn.style.cursor = 'pointer';
      displayAllBtn.addEventListener('click', () => {
        root.traverse(n => { try { n.visible = true; } catch (e) {} });
        controlsPane.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = true; cb.disabled = false; cb.parentElement.style.opacity = '1'; });
        requestRender();
      });
      displayAllRow.appendChild(displayAllBtn);
      fragment.appendChild(displayAllRow);
      controlsPane.appendChild(fragment);
      window._groupMap = groupMap;
    }

    /* Responsive renderer sizing: handle portrait (bottom controls) and landscape (left controls) */
    function updateRendererSize() {
      const sidebar = document.getElementById('sidebar');
      const isPortrait = window.matchMedia('(orientation: portrait)').matches;
      if (!sidebar) {
        const w = Math.max(window.innerWidth - 300, 100);
        const h = window.innerHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        return;
      }

      if (isPortrait) {
        // controls are at bottom: measure their height (CSS limits it to --controls-height-vh)
        const sidebarRect = sidebar.getBoundingClientRect();
        const controlsHeight = Math.min(sidebarRect.height, window.innerHeight * 0.9); // safe cap
        const w = Math.max(window.innerWidth, 100);
        const h = Math.max(window.innerHeight - controlsHeight, 100);
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        // do NOT set viewerEl.style.height here; CSS flex manages it
      } else {
        // landscape: sidebar left with fixed width
        const sidebarWidth = sidebar.getBoundingClientRect().width || 300;
        const w = Math.max(window.innerWidth - sidebarWidth, 100);
        const h = window.innerHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }
      requestRender();
    }

    // initial sizing and event listeners
    updateRendererSize();
    window.addEventListener('resize', () => updateRendererSize());
    // also respond to orientation changes explicitly
    window.addEventListener('orientationchange', () => setTimeout(updateRendererSize, 120));

    // initial render kick (already safe because needsRender etc are declared)
    requestRender();

  </script>
  <div id="copyright-watermark">
  © Pro'ximo All Rights Reserved.
  </div>
</body>
</html>

