<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GLB Viewer — Collection 切替スイッチ</title>
  <style>
    html,body{height:100%;margin:0;font-family:system-ui, -apple-system, 'Segoe UI', Roboto, 'Hiragino Kaku Gothic ProN', 'Noto Sans JP';}
    #app{display:grid;grid-template-columns:300px 1fr;height:100vh}
    #sidebar{padding:12px;border-right:1px solid #ddd;overflow:auto}
    #viewer{background:#111}
    .collection-item{display:flex;align-items:center;margin:6px 0}
    label{margin-left:8px}
    header{font-weight:700;margin-bottom:8px}
    .hint{font-size:13px;color:#666;margin-top:10px}
    button{margin-top:8px;padding:6px 10px;border-radius:6px;border:1px solid #ccc;background:#fff}
  </style>

<script type="importmap">
        {
            "imports": {
                 "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
      "OrbitControls": "https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js",
      "GLTFLoader": "https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js"
            }
        }
    </script>
  
</head>
<body>
  <div id="app">
    <aside id="sidebar">
      <header>コレクション表示切替</header>
      <div id="controls">読み込み中…</div>
      <div class="hint">※GLB 内のノード名（Collection等）を元に自動で一覧化します。ノード名は Blender 等で設定してください。</div>
      <button id="resetBtn">全て表示</button>
    </aside>
    <main id="viewer"></main>
  </div>
  
  
 <script type="module">
/* モジュール版 three + examples/jsm を CDN から直接 import */
import * as THREE from 'three';
import { OrbitControls } from 'OrbitControls';
import { GLTFLoader } from 'GLTFLoader';

const GLB_PATH = 'mouthmove-demo2-18.glb'; // index.html と同じ階層ならこれで OK

const container = document.getElementById('viewer');
const controlsPane = document.getElementById('controls');
const resetBtn = document.getElementById('resetBtn');

// three.js セットアップ
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, (window.innerWidth - 300) / window.innerHeight, 0.1, 1000);
camera.position.set(0, 1.6, 3);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth - 300, window.innerHeight);
container.appendChild(renderer.domElement);

const orbit = new OrbitControls(camera, renderer.domElement);
orbit.target.set(0, 1, 0);
orbit.update();

// 簡易ライティング
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
hemi.position.set(0, 20, 0);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(3, 10, 10);
scene.add(dir);

let modelRoot = null;

const loader = new GLTFLoader();
controlsPane.innerText = '読み込み中…';
loader.load(GLB_PATH, (gltf) => {
  const model = gltf.scene || (gltf.scenes && gltf.scenes[0]);
  if (!model) {
    controlsPane.innerText = 'モデルが空です（gltf.scene が null）。Console を確認してください。';
    console.error('gltf.scene is null', gltf);
    return;
  }
  modelRoot = model;
  scene.add(model);

  // バウンディングボックスでカメラ調整
  const bbox = new THREE.Box3().setFromObject(model);
  const size = bbox.getSize(new THREE.Vector3()).length();
  const center = bbox.getCenter(new THREE.Vector3());
  orbit.target.copy(center);
  orbit.update();
  camera.position.copy(center).add(new THREE.Vector3(0, size * 0.5, size * 1.5));
  camera.updateProjectionMatrix();

  // デバッグ出力（ノード一覧） — optional（読み込み成功の目安）
  // controlsPane.innerHTML = '<strong>ロード成功 — ノード一覧（デバッグ）</strong><div id="nodeList" style="margin-top:8px;font-size:13px;"></div>';
  // const nodeList = document.getElementById('nodeList');
  // let count = 0;
  // model.traverse((node) => {
  //   const name = node.name && node.name.trim() ? node.name : '(no-name)';
  //   const type = node.type || (node.isMesh ? 'Mesh' : 'Object3D');
  //   const children = node.children ? node.children.length : 0;
  //   const info = `${++count}. name: "${name}"  type: ${type}  children: ${children}`;
  //   const el = document.createElement('div');
  //   el.textContent = info;
  //   nodeList.appendChild(el);
  //   console.log(info, node);
  // });

  // ビューのツリー UI を構築（深さ 2 まで展開）
  //buildTreeUI(model, 1);
buildGroupedUI(model);
  
}, (xhr) => {
  // onProgress: xhr は ProgressEvent で lengthComputable を使うことが多い
  try {
    if (xhr && xhr.lengthComputable) {
      controlsPane.innerText = `読み込み中… ${(xhr.loaded / xhr.total * 100).toFixed(0)}%`;
    } else {
      controlsPane.innerText = `読み込み中…`;
    }
  } catch (e) {
    controlsPane.innerText = `読み込み中…`;
  }
}, (err) => {
  controlsPane.innerText = '読み込みに失敗しました（エラー）。Console を確認してください。';
  console.error('GLB load error:', err);
});

// ---- ツリー UI（深さ制限あり） ----
// ---- グループ化された UI を作る ----
// v<数字>. で始まるノード（例: "v1.a-あ"）をグループ扱いにして、
// ラベルから先頭の「v」を取り除いた文字列（"1.a-あ"）を表示する。
// 見つからない場合はフォールバックでルート直下をツリー表示します。

function buildGroupedUI(root) {
  controlsPane.innerHTML = '';

  if (!root) {
    controlsPane.innerText = 'モデルが未ロードです';
    return;
  }

  // 1) vN.* パターンの親ノードを探す（直下にある場合を優先）
  const grouped = [];
  const pattern = /^v\d+\./; // v1. v2. など

  // 優先：root の直下にあるものから探す
  if (root.children && root.children.length) {
    root.children.forEach(child => {
      if (child.name && pattern.test(child.name)) {
        grouped.push(child);
      } 
    });
  }

  // 見つからなければシーン全体を走査して探す（深部にある場合）
  if (!grouped.length) {
    root.traverse(node => {
      if (node !== root && node.name && pattern.test(node.name)) {
        grouped.push(node);
      }
    });
  }

  // UI に出す要素（見つかったグループがあればそれらを1つずつ表示）
  const fragment = document.createDocumentFragment();

  if (grouped.length) {
    grouped.forEach((groupNode, idx) => {
      // 表示名：先頭の 'v' を除く（例: v1.a-あ -> 1.a-あ）
      const rawName = groupNode.name || `group_${idx}`;
      const labelName = rawName.startsWith('v') ? rawName.slice(1) : rawName;

      // 行を作る（checkbox + label + optional expand）
      const row = document.createElement('div');
      row.className = 'collection-item';
      row.style.display = 'flex';
      row.style.alignItems = 'center';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = (typeof groupNode.visible !== 'undefined') ? groupNode.visible : true;
      checkbox.id = `group_${idx}`;
      checkbox.style.marginRight = '8px';

      const label = document.createElement('label');
      label.htmlFor = checkbox.id;
      label.textContent = labelName;

      row.appendChild(checkbox);
      row.appendChild(label);

      // クリック時は groupNode とその子孫すべてを切り替え
      checkbox.addEventListener('change', () => {
        const v = checkbox.checked;
        setVisibilityRecursive(groupNode, v);
      });

      // （任意）ラベルクリックでトグル
      label.addEventListener('click', () => {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event('change'));
      });

      // さらに「展開ボタン」を付けて、中身のツリーを表示する（クリックで展開）
      const expandBtn = document.createElement('button');
      expandBtn.textContent = '表示▼';
      expandBtn.style.marginLeft = '12px';
      expandBtn.style.fontSize = '12px';
      expandBtn.style.padding = '3px 6px';
      expandBtn.style.cursor = 'pointer';

      // 子ツリー領域（最初は非表示）
      const subContainer = document.createElement('div');
      subContainer.style.marginLeft = '18px';
      subContainer.style.display = 'none';

      expandBtn.addEventListener('click', () => {
        const opened = subContainer.style.display !== 'none';
        subContainer.style.display = opened ? 'none' : 'block';
        expandBtn.textContent = opened ? '表示▼' : '非表示▲';
      });

      row.appendChild(expandBtn);
      fragment.appendChild(row);

      // サブツリーを作る（深さ 2 までの簡易ツリー表示。チェックは親と独立）
      // createSubTree は以下で定義
      subContainer.appendChild(createSubTree(groupNode, 0, 2));
      fragment.appendChild(subContainer);
    });

  } else {
    // 見つからない場合はフォールバックで普通のツリー（深さ2）を出す
    // （既存の buildTreeUI を呼ぶ代わりにここから作る）
    if (root.children && root.children.length) {
      root.children.forEach(child => {
        fragment.appendChild(createSubTree(child, 0, 2));
      });
    } else {
      fragment.appendChild(createSubTree(root, 0, 2));
    }
  }

  controlsPane.appendChild(fragment);

  // reset ボタン
  resetBtn.onclick = () => {
    root.traverse(n => { if (typeof n.visible !== 'undefined') n.visible = true; });
    document.querySelectorAll('#controls input[type="checkbox"]').forEach(cb => cb.checked = true);
  };
}

// createSubTree: node の subtree を作る（深さ制限あり）
// - このサブツリー上のチェックは、そのノードとその子孫のみを切る（親グループの on/off とは併存します）
function createSubTree(node, depth, maxDepth) {
  const wrapper = document.createElement('div');
  wrapper.style.display = 'flex';
  wrapper.style.flexDirection = 'column';
  wrapper.style.marginLeft = '6px';

  const row = document.createElement('div');
  row.style.display = 'flex';
  row.style.alignItems = 'center';
  row.style.gap = '8px';
  row.style.margin = '4px 0';

  const hasChildren = node.children && node.children.length > 0;

  const toggleBtn = document.createElement('button');
  toggleBtn.style.border = 'none';
  toggleBtn.style.background = 'transparent';
  toggleBtn.style.cursor = hasChildren ? 'pointer' : 'default';
  toggleBtn.style.width = '18px';
  toggleBtn.style.padding = '0';
  toggleBtn.textContent = hasChildren ? '▸' : ''; // ▶
  row.appendChild(toggleBtn);

  const input = document.createElement('input');
  input.type = 'checkbox';
  input.checked = (typeof node.visible !== 'undefined') ? node.visible : true;
  row.appendChild(input);

  const label = document.createElement('label');
  label.textContent = node.name && node.name.trim() ? node.name : '(no-name)';
  row.appendChild(label);

  wrapper.appendChild(row);

  const childContainer = document.createElement('div');
  childContainer.style.marginLeft = '18px';
  childContainer.style.display = (hasChildren && depth < maxDepth) ? 'block' : 'none';
  wrapper.appendChild(childContainer);

  input.addEventListener('change', () => {
    const checked = input.checked;
    setVisibilityRecursive(node, checked);
    // sync child checkboxes in this subContainer
    childContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = checked);
  });

  toggleBtn.addEventListener('click', () => {
    if (!hasChildren) return;
    const opened = childContainer.style.display !== 'none';
    childContainer.style.display = opened ? 'none' : 'block';
    toggleBtn.textContent = opened ? '▸' : '▾';
  });

  label.addEventListener('click', () => { input.checked = !input.checked; input.dispatchEvent(new Event('change')); });

  if (hasChildren) {
    node.children.forEach(child => {
      childContainer.appendChild(createSubTree(child, depth + 1, maxDepth));
    });
  }

  return wrapper;
}

// setVisibilityRecursive: node とその子孫の visible を set
function setVisibilityRecursive(node, visible) {
  if (typeof node.visible !== 'undefined') node.visible = visible;
  if (node.children && node.children.length) {
    node.children.forEach(c => setVisibilityRecursive(c, visible));
  }
}



   
// リサイズ処理（viewer の幅はサイドバー 300px を差し引く）
window.addEventListener('resize', () => {
  const w = window.innerWidth - 300;
  const h = window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
});

// レンダーループ
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
</script>


   
</body>
</html>


<!-- README（短い手順） -->

<!--
使い方:
1) リポジトリ構成例:
   /index.html  <- このファイル
   /models/mouthmove-demo2-18.glb  <- アップロードした GLB

2) GitHub に push する
   - リポジトリを作成してファイルを追加して push してください。
   - GitHub Pages で公開する方法: Settings -> Pages から "branch: main" と "/ (root)" を選ぶか、/docs フォルダに入れて "branch: main /docs" を選択してください。
   - もしくは gh-pages ブランチを作って公開しても OK。

3) パスの確認
   - GLB のパスが変わる場合は、index.html 内の GLB_PATH を編集してください。

4) Blender での準備
   - コレクション名（Collection）をノード名（Object 名）としてエクスポートすると、このビューワで見やすくなります。
   - ノード名が空の場合は自動で Collection_0 などの名前が付けられます。

補足:
- より細かく "メッシュごと" や "子ノードまで展開してトグル" したい場合は、findCollections 関数をカスタマイズしてください。
- セキュリティ: GitHub Pages では raw.githubusercontent.com から直接モデルを読み込むのも可能ですが、同じリポジトリに置くのが簡単です。
-->











